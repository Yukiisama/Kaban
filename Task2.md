# Task 2

| ID    | Titre                                                        | Description                                                  | DOD                                                          | Dépendances  | US         | Estimation (h.h) | Etat  | Assignation    |
| ----- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------ | ---------- | ---------------- | ----- | -------------- |
| T2-00 | Refactor                                                     | Refactor du code produit lors du sprint 1. L’équipe doit se réunir sur Liveshare pour discuter et refactorer le code produit. | L’équipe est d’accord sur le code obtenu après le refactor   |              |            | 5                | DOING | Toute l'équipe |
| T2-02 | Créer l’endpoint pour la gestion des us                      | Créer l’endpoint ‘/api/v1/us’ qui expose les méthodes GET, POST, PUT, DELETE. | L’endpoint doit être accessible et répondre correctement aux requêtes. | T0-00, T2-03,T2-20 | US-5, US-6 | 3                | DONE | Robin |
| T2-01 | Créer le modèle pour représenter une US côté front.          | Créer dans le dossier front/src/app/models le fichier us.model.ts, qui exporte la classe US. La classe US doit contenir tous les champs qui définissent un US tel: id : intproject_id : intname: stringpriority : enum Low, Medium, Highdifficulty: int | Le fichier est créé. La classe US est utilisable dans le reste de la partie front. | T0-00        | US-5, US-6 | 1                | DONE  |     Alexis           |
| T2-03 | Créer la classe UserStory côté back                          | Créer la classe java UserStory dans le domain. Cette classe est composé de : id (int), project_id (int), name (string), priority (string), difficulty (int) | La classe doit être créée.                                   | T0-00        | US-5, US-6 | 1                | DONE | Robin          |
| T2-04 | Créer le dao pour les us.                                    | Créer l’interface DAOUserStory, et son implémentation SQLDAOUserStory. Ajouter dans l’interface DAOFactory la méthode getUserStoryDAO et implémenter l’implémenter dans SQLDAOFactory. L’interface doit exposer les méthodes :getAllForProject(int projectId)insert(UserStory)update(UserStory)Les tests testant le bon fonctionnement de ces fonctions doivent être écrits. | L’interface a été créée.La classe a été créée.La méthode getUserStoryDAO a été ajoutée dans l’interface de l’implémentation en sql a été réalisée.Les tests sont rédigés et passent. | T2-03        | US-5, US-6 | 2                |   DONE    |    Adrien            |
| T2-05 | Créer le service pour la gestion des US côté front           | Créer dans le dossier /front/src/app/services le service us.service.ts Ce service communique avec l’endpoint ‘/api/us’, il doit exposer les méthodes: <br>    - getAllForProject(int projectId)<br>    - getById(int projectId, int usId)<br>    - post(Us)<br>    - delete(US)<br>    - update(US) | Expose un set de méthodes.Le service envoie les bonnes requêtes au serveur. | T2-01,T2-02  | US-5, US-6 | 2                | DONE | Robin |
| T2-06 | Créer le schéma de la table US dans la BDD                   | Créer le script de création de la table us et un test d'insertion. Elle doit être composée des champ suivants:project (int, référence vers project.id)id (int, auto-increment)description (longtext)priority (ENUM(Low, Medium, High))difficulty (int)clé primaire (projet, id) | Le script doit s'exécuter lors de la création de la base de donnéesLe test d'insertion doit fonctionner | T0-00        | US-5, US-6 | 1                | DONE  |   Adrien             |
| T2-07 | Créer le modèle pour représenter un Sprint côté front.       | Créer dans le dossier front/src/app/models le fichier us.model.ts, qui exporte la classe Sprint. La classe Sprint doit contenir tous les champs qui définissent un sprint tel: name : stringnbTasks : intusList : List of US or an object UsList or List of ids of each Us.tasksList : List of Tasks or an object TaskList or List of ids of each tasks. | Le fichier est créé. La classe Sprint est utilisable dans le reste de la partie front. | T0-00        | US-5       | 1                | DONE | Robin |
| T2-08 | Créer la classe Sprint côté back                             | La classe Sprint est un Value Object qui correspond aux données décrites dans T2-12 | L'objet doit être déclaréL'objet doit être instancié dans un test | T0-00        | US-5       | 1                | DONE |       Alexis         |
| T2-09 | Créer la DAO pour les sprints                                | Créer l’interface DAOSprint, et son implémentation SQLDAOSprint. Ajouter dans l’interface DAOFactory la méthode getSprintDAO et implémenter l’implémenter dans SQLDAOFactory. L’interface doit exposer les méthodes :getAllForProject(int projectId)insert(Sprint)update(Sprint)Ajouter des tests pour vérifier que toutes les méthodes marchent | L'interface et son implémentation doivent être codées et utilisablesUn test d'insertion, de modification et d'accès de l'objet doivent être écrits | T2-08        | US-5       | 2                | DONE |    Alexis    |
| T2-10 | Créer l’endpoint pour la gestion des sprints                 | Créer l’endpoint ‘/api/sprint’ qui expose les méthodes GET, POST, PUT, DELETE. | L’endpoint doit être accessible et répondre correctement aux requêtes. | T0-00        | US-5       | 2                | DONE  |       Alexis         |
| T2-11 | Créer le service pour la gestion des sprints côté front      | Créer dans le dossier /front/src/app/services le service sprint.service.ts Ce service communique avec l’endpoint ‘/api/sprint’, il doit exposer les méthodes: getSprintList() : USListgetSprint(string name) : sprintaddSprint(Sprint) : booleandeleteSprint(Sprint) : booleanupdateSprint(Sprint) : boolean | Expose un set de méthodes.Le service envoie les bonnes requêtes au serveur. | T2-06,T2-05  | US-5       | 2 | DONE | Robin |
| T2-12 | Créer le schéma de la table sprints dans la BDD              | Créer le script de création de la table sprint et un test d'insertion. Elle doit être composée des champ suivants:project (int, référence a project.id)id (int, auto-increment)name (text)clé primaire (project, id)l'id est incrémenté de manière relative par rapport au projet (clé primaire composite) | Le script doit s'exécuter lors de la création de la base de donnéesLe test d'insertion doit fonctionner | T0-00        | US-5       | 2                | DONE   |  Alexis              |
| T2-13 | Créer le composant Backlog                                   | Créer le composant Backlog permettant de visualiser le backlog d’un projet. Créer une section “Backlog” centrée dans la page en largeur.Créer une section “Sprint” contenant chaque sprint composé tel que :<br>    - Nom du sprint en haut à gauche<br>    - Nombre de tâches associées à ce sprint.<br>    - Liste des US correspondantes. Pour chaque élément, on affichera:<br>        - L’identification<br>        - Le nom<br>        - Un icône priorité ( Flèche vers le haut ou vers le bas, de couleurs différentes)<br>        - La difficultée<br>Créer un bouton “Créer un sprint”, ajoutant une nouveau sprint vierge dans la section Sprint.<br>Une section *backlog* en bas doit contenir toutes les us non planifiées. | Le composant BackLog a été créé. Une section BackLog et Sprint ont été créés. On peut créer en sprint en appuyant sur le bouton “Créer un sprint”. | T2-05, T2-06 | US-5       | 4               | DOING | Robin |
| T2-14 | Créer le formulaire d’ajout d’US                             | Récupérer la liste des rôles possibles (api?, stocké dans le ts?, autre ?) Créer un formulaire, dans le composant Backlog, avec pour champ:Numéro de l’identification de l’US : le champ doit être pré-rempli avec “US-num”, avec num étant le nombre d’US actuel incrémenté: le champ est modifiable et reste valide tant que l’id reste unique.Nom de l’US formaté de la manière suivante dans une seule et même phrase:      - Une zone de texte non modifiable: “En tant que” - rôle : un menu déroulant contenant les différents rôles possibles et une possibilité d’ajouter un rôle pour le projet avec un champ “autre”.- Une zone de texte non modifiable: “je souhaite” - Une zone de texte modifiable- Une zone de texte non modifiable “afin de”- Une zone de texte modifiable. Priorité de l’US : un menu déroulant avec comme choix: Low, Medium, HighLa difficulté de L’US : un menu déroulant avec comme choix des nombres de la suite de Fibonacci. Sous la section “Sprint”, créer un bouton “Ajouter une User Story” permettant l'ajout de nouvelles US via le formulaire créé. | On peut ajouter une User Story en appuyant sur le bouton “Ajouter une User Story” | T0-00        | US-6       | 2                | TODO  |                |
| T2-15 | Bouton démarrer un sprint. | Afficher le bouton 'démarrer le sprint' dans les sprints de la section *backlog*. Cette action ne doit être disponible que si aucun sprint n'a actuellement lieux.<br>Si l'action est disponible, alors en cas de click le sprint doit être défini en tant que sprint actif, et une redirection doit avoir lieux. | Le bouton apparait, mais n'est cliquable que si aucun sprint actif n'est défini.<br>Cliquer défini le sprint comme actif, la redirection a lieux. | T2-12 | US-5 | 1 | TODO | |
| T2-16 | Modifier le sprint d’une US par un glisser-déposer           | Créer coté front, la possibilité de glisser déposer une US d’un sprint ou appartenant à la section US, pour changer sa planification. Le mouvement de glisser déposer n’est possible que par le scrumMaster. Le mouvement de glisser déposer doit être valide: issu d’une US et vers un sprint ou la section us.Le mouvement de glisser déposer est impossible si l’US sélectionnée n’a pas toutes ses tâches liées dans la catégorie TODO. Si le mouvement de glisser déposer est invalide, l’US sélectionnée retrouve sa place initiale. Si le mouvement de glisser déposer est valide, alors l’US est ajoutée à la zone choisie, et la planification est changée. | On peut effectuer un glisser déposer d’une US dans une zone valide et changer sa planification si on est le Scrum Master. Si la zone n’est pas valide, alors l’US reprend sa place. | T2-15        | US-7       | 3                | DOING | Robin |
| T2-18 | Créer le schéma de la table task ainsi que leur interdépendance | Créer le script de création de la table task et un test d'insertion. Elle doit être composée des champ suivants:project (int, référence a project.id)id (int, auto-increment)titre (text)durée (text)us (int, référence à us.id)status (text) clé primaire (project, id)l'id est incrémenté de manière relative par rapport au projet (clé primaire composite) Créer la table task_dep qui est une table d'association entre teux task.id | Le script doit s'exécuter lors de la création de la base de donnéesUn test d'insertion doit fonctionner | T0-00        | US-15      | 1                | DONE  |   Adrien             |
| T2-19 | Créer la classe Task côté back                               | La classe Task est un Value Object qui correspond aux données décrites dans T2-20 | L'objet doit être déclaréL'objet doit être instancié dans un test | T0-00        | US-15      | 1                | DONE  | Robin |
| T2-20 | Créer le dao pour la gestion des tasks                       | Créer l’interface DAOTask, et son implémentation SQLDAOTask. Ajouter dans l’interface DAOTask la méthode getTaskDAO et l’implémenter dans SQLDAOFactory. L’interface doit exposer les méthodes :getAllForProject(int projectId) -> List<Task >insert(Task) -> Taskupdate(Task)get(int projectId, int taskId) -> TaskgetTasksOfSprintForProject(int projectId, int sprint) -> List<Task> getTasksOfUserStoryForProject(int projectId, int us) -> List<Task> getDependantTasks(int taskId) -> List<Task>getDependingTasks(int taskId) -> List<Task>Ajouter des tests pour vérifier que toutes les méthodes marchent | L'interface et son implémentation doivent être codées et utilisablesUn test d'insertion, de modification et d'accès de l'objet doivent être écrits | T2-19        | US-15      | 2                | DONE | Robin |
| T2-21 | Créer l’endpoint pour la gestion des tasks                   | Créer l’endpoint ‘/api/tasks qui expose les méthodes GET, POST, PUT, DELETE. | Les requêtes doivent modifier correctement la base de donnée. | T2-19, T2-20 | US-15      | 3                | DONE | Robin |
| T2-22 | Créer le modèle côté front pour représenter une Task         | Créer le fichier Task.model.ts qui exporte la classe Tasks. Elle doit comporter les même champs que Task.java côté back. | Le fichier est créé.La classe peut être instanciée correctement à partir du json reçu depuis le back. | T0-00        | US-15      | 1                | DONE  |       Alexis         |
| T2-23 | Créer le service task pour communiquer avec le back          | Créer le service front qui communique avec le back pour récupérer les tasks.Le service doit exposer les méthodes :getTaskForUs(usId: number)getTaskForProject(usId: number)updateTask(task)deleteTask(task) | Le service est créé et est injectable dans les composants.Les appels aux méthodes du service génèrent bien une requête au serveur. | T2-22        | US-15      | 2                | DONE | Robin |
| T2-24 | Créer le composant task-card                                 | Ce composant doit pouvoir contenir les informations nécessaires à l’identification d’une task:Le titreL’identifiantLes US associées (pas sûr)Ce composant correspond a une version minimale d’une tâche. Si l’utilisateur clique sur le titre de ce composant cela ouvrira une pop un contenant un composant expanded-task-card .Ce composant doit afficher l’avancement de la dod sous forme forme fractionnaire (“3/5” par exemple) | Les informations détaillant une tâche sont bien affichées.   | T2-23        | US-16      | 3                | DONE|    Alexis            |
| T2-25 | Créer le composant task-container.                           | Ce composant doit pouvoir contenir des task-card.Il affichera les différentes taches qui le composent. Il correspond à un état de la tâche. On doit pouvoir retirer ou ajouter un composant task-card par un mouvement de cliquer déposer. | Le container ainsi que l’état sont bien affichés. Toutes les tâches sont présentes.L’ajout d’une tâche dans ce composant entraîne l’affichage de celle-ci.La suppression d’une tâche de ce composant entraîne la disparition de cette tâche. On peut déplacer une tâche. | T2-23        | US-16,     | 2                | DONE |       Alexis         |
| T2-26 | Créer le composant contenant le formulaire de création de Tasks | Ajouter un bouton dans le composant task qui ouvre un formulaire. Celui permettra de créer une nouvelle tâche et comportera comme champs :Un identifiant (auto-incrément) un titre (30 caractères max) (obligatoire)une description (200 caractères max) une Dod (liste de chaînes de 50 caractères max) (obligatoire)les dépendances (checkbox (ou menu déroulant) des identifiants des tâches déjà créées)les Us associées (checkbox(ou menu déroulant) des identifiants des Us déjà créées)un état (to-do pas défaut)un membre en charge (checkbox des membres existants du projet) | L’appuie sur le bouton affiche le formulaire.Il est possible d’ajouter une nouvelle tâche.Il est possible d’annuler l’ajout d’une tâche. | T2-25        | US-15      | 2                | DONE |       Alexis         |
| T2-27 | Créer le composant expanded-task-card                        | Ce composant doit pouvoir afficher les informations relatives à une Task. On doit pouvoir y voir :<br>L’identifiant Le titre <br>La description <br> Le chiffrage <br> La DoD <br> Les dépendances <br> Les Us associées <br> Un type <br> Le membre de l’équipe en charge <br> Ce composant correspond au détail d’une tâche lorsque l’on clique sur une task-card. | Toutes les informations d’une tâche sont affichées.          | T2-23        | US-15      | 2                | DONE |     ALEXIS           |
| T2-28 | Afficher les Tâches dans les différentes colonnes            | Dans le composant Task ajouter trois composants task-container. Correspondant respectivement aux états “TODO” “DOING” et “DONE”. | Les trois colonnes sont visibles et les tâches correspondantes sont affichées. |              | US-16      | 2                | DONE  |       Alexis         |
| T2-29 | Ajouter l’édition et la suppression d’une task               | L’édition doit être disponible dans le composant expanded-task-card. Ajouter un bouton Modifier dans le composant de sorte à ce que les informations affichées deviennent modifiables par l’utilisateur. Deux boutons “annuler” et "valider" permettront de passer à la version non-modifiable. Les informations modifiées seront mise à jour si l’utilisateur a appuyé sur “valider” | Il est possible de cliquer sur le bouton d’édition. Tous les champs autorisés doivent devenir éditables.Cliquer sur le bouton valider doit modifier la tâche.Cliquer sur le bouton annuler ne doit pas modifier la tâche. | T2-27        | US-16      |                  | DOING   |    Alexis            |
| T2-30 | Gestion de la DOD dans expanded-task-card                    | La liste des éléments de la dod doit être affichée. Il doit y avoir une checkbox permettant de checker un élément de la dod. Un élément checké doit apparaître rayé. | Tous les items doivent pouvoir être cochés et passer en mode “rayé”Tous les items doivent pouvoir être décochés et perdre le mode “rayé”. | T2-27        | US-17      | 2                | Doing   |      Alexis          |
| T2-31 | Ajout du filtrage des tâches                                 | Créer un menu déroulant dans la section Task proposant différents filtres, masquant les tâches ne correspondant pas au filtre. Les filtres présent sont :par sprintpar membrepar usIl doit être possible d’appliquer plusieurs filtres. | Les filtres sont applicables, et ne laissent affiché que les tâches correspondantes aux filtres. | T2-25        | US-19      | 3                | TODO  |                |
| T2-32 | Possibilité de sélectionner des dépendances pour les ajouter à une tâche | Modifier sur le formulaire de création de tâche se trouvant dans Task la partie dépendance d’une tâche. Créer un menu déroulant avec pour entrée les différentes tâches existantes dans le projet: sélectionner une tâche ou plusieurs tâches ( liste à cocher) les ajoute en dépendances à la tâche actuelle. Chaque tâche sera affichée sous forme de task-card. | Le menu doit être visible et tous les items doivent pouvoir être cochés. Il doit être possible de visualiser les infos de chaque tâches. | T2-27        | US-15      |                  | DONE  |      Alexis          |
| T2-33 | Créer la classe member côté back                             | La classe Member est un Value Object qui correspond aux données décrites dans T2-34 | L'objet doit être déclaréL'objet doit être instancié dans un test | T2-34        | US-9       | 1                | DONE | Chaïma |
| T2-34 | Créer le schéma de la table member dans la base de donnée    | Créer le script de création de la table member et un test d'insertion. Elle doit être composée des champ suivants:project (int, référence a project.id)user (int, auto-increment)role (text)level (text)clé primaire (project, user) | Le script doit s'exécuter lors de la création de la base de donnéesLe test d'insertion doit fonctionner | T0-00        | US-9       | 1                | DONE | Chaïma |
| T2-35 | Créer le dao pour Member                                     | Créer l’interface DAOMember, et son implémentation SQLDAOMember. Ajouter dans l’interface DAOFactory la méthode getMemberDAO et l’implémenter dans SQLDAOFactory. L’interface doit exposer les méthodes :getAllForProject(int projectId) -> List<Member>create(int projectId, int user, string role)update(Member)get(int projectId, int user) -> MembergetMemberOfRoleForProject(int projectId, string role) -> List<Member> getMemberOfLevelForProject(int projectId, string level) -> List<Member> à voir selon le schéma retenu pour la base de données au niveau des paramètres user. Si l'user est généré en autoincrement, il faut retourner son id dans create.Rajouter des tests pour vérifier que toutes les méthodes marchent | L'interface et son implémentation doivent être codées et utilisablesUn test d'insertion, de modification et d'accès de l'objet doivent être écrits | T2-34        | US-9       | 2                | DONE | Chaïma |
| T2-36 | Créer l’endpoint pour la gestion des membres                 | Créer l’endpoint permettant de gérer les membres. Les opérations GET, UPDATE, POST et DELETE doivent être disponibles. | Les routes doivent être accessibles.La bdd est bien mise à jour en fonction des routes utilisées. | T2-33        | US-9       | 2                | DONE | Chaïma |
| T2-37 | Créer le model côté front pour la gestion des membres        | Créer le fichier member.model.ts exportant la classe Member. Cette classe doit posséder les mêmes champs que Member.java côté back. | Le fichier est créé, la classe est instanciable avec le json reçu depuis le serveur. | T2-33        | US-9       | 1                | DONE | Chaïma |
| T2-39 | Créer le service côté front pour communiquer avec l’endpoint gérant les membres | Créer le fichier member.service.ts. Ce service doit communiquer avec l’endpoint gérant les membres. | Le service est créé et est injectable dans les composants. L’appel aux méthodes envoie la requête appropriée au serveur. | T2-36        | US-9       | 2                | DONE | ChaïmaChaïma |
| T2-40 | Créer le composant member-list et créer le composant member-item | Créer le composant member-item affichant un membre. Le composant doit afficher le nom, le rôle et le niveau d’un membre.Ce composant permet d’afficher la liste des membres d’un projet.Le composant member-list doit être affiché dans la section planification. | Les composants sont créés.                                   | T2-39        | US-9       | 1                | DONE | ChaïmaChaïma |
| T2-42 | Créer le formulaire pour l’ajout d’un membre et ajout du bouton pour l’ouvrir | Dans le composant Planification ajouter un bouton près de la liste de membres permettant d'ajouter un nouveau membre.Ce formulaire comportera :Nom (string 50 caractères max) (obligatoire)Rôle (menu déroulant : owner, admin, developper)Niveau (menu déroulant : junior, senior)Un bouton ouvrant le formulaire d’ajout doit être ajouté dans la section planification. | Lors de l’ajout d’un membre, une requête post est envoyée au serveur.Lors du clique sur le bouton d’ajout, le formulaire s’ouvre. | T2-39        | US-9       | 3                | Doing | Chaïma |
| T2-43 | Créer l’algorithme de répartition des tâches                 | Recherche solution algorithmique.ConceptionOptimisation (complexité temps, mémoire)Mise en application (i.e code)Tests | L’algorithme doit pouvoir être lancé.Toutes les tâches doivent avoir été assignées. | T2-42        | US-10      | 5                | TODO  |                |
| T2-44 | Afficher la répartition des tâches générée par l’algo        | Afficher sous forme d’un tableau à deux dimensions la répartition. En haut doit se trouver le temps, et sur le côté les membres. | Le tableau doit pouvoir être visible et correspondre à celui attendu. | T2-44        | US-10      | 4                | TODO  |                |
| T2-45 | Créer le schéma de la table dod                              | Créer le script de création de la table dod et un test d'insertion. Elle doit être composée des champ suivants:project (int, référence a task.project)task (int, référence à task.id)id (int, auto increment)label (text)state (boolean)clé primaire (project, task, id) | Le script doit s'exécuter lors de la création de la base de donnéesUn test d'insertion doit fonctionner | T0-00        | US-17      | 1                | DONE  |     Adrien           |
| T2-46 | Créer l'objet DOD dans le back                               | La classe DOD est un Value Object qui correspond aux données décrites dans T2-45 | L'objet doit être déclaréL'objet doit être instancié dans un test | T0-00        | US-17      | 1                | DONE  |       Adrien         |
| T2-47 | Créer le DAO pour DOD                                        | Créer l’interface DAODOD, et son implémentation SQLDAODOD. Ajouter dans l’interface DAOFactory la méthode getDODDAO et l’implémenter dans SQLDAOFactory. L’interface doit exposer les méthodes :getAllForTask(int projectId, int task) -> List<DOD>create(int projectId, int task, DOD)update(Member)get(int projectId, int user) -> MembergetMemberOfRoleForProject(int projectId, string role) -> List<Member> à voir selon le schéma retenu pour la base de données au niveau des paramètres user. Si l'user est généré en autoincrement, il faut retourner son id dans create.Ajouter des tests pour vérifier que toutes les méthodes marchent | L'interface et son implémentation doivent être codées et utilisablesUn test d'insertion, de modification et d'accès de l'objet doivent être écrits | T2-46        | US-17      | 2                | DONE  |       Adrien         |
| T1-22 | Créer la release du sprint 2                                 | Créer la release pour la fin du sprint 2. Le fichier .war pour le serveur doit être généré, et le front doit être compilé en version production. | En faisant docker-compose up, l’application doit être lancée et accessible. | T0-00        |            | 2                | TODO  |                |
| T1-03 | Créer la section how-to                                      | Créer le composant “how-to” contenant les instructions pour l’utilisation du site. Cette page contient une section pour chaque partie du site. Ces sections doivent contenir l’iframe pour afficher la vidéo d’explication.Créer le bouton en haut à droite redirigeant sur la page “how-to”. Quand l’utilisateur est dans une section spécifique, il doit être redirigé sur l’ancre correspondant à la section. | L’icon ‘how-to’ est présent sur chaque section du site. Cliquer dessus redirige sur la page how-to, sur la section correspondant à la “page” actuelle.How-to comporte bien une section pour chaque partie du site, avec les explications correspondantes. | T0-00        | US-1       | 2                | TODO  |                |
| T1-27 | Ajouter la création d'un projet                              | Créer le bouton de création d'un nouveau projet dans le composant ProjectList. Créer un bouton “Nouveau projet” en haut de la page proche de la barre de recherche. Ce bouton doit ouvrir un encart contenant un formulaire. Ce formulaire est composé d’un input pour le titre du projet, et d’un text area pour la description.Un bouton valider doit permettre d’envoyer une requête de création au serveur, et un bouton abandonner doit permettre de faire disparaître l’encart, sans que le       projet n'ait été créé. | Cliquer sur le bouton nouveau projet ouvre le formulaire de création et on peut écrire dans les champs.Cliquer sur le bouton valider du formulaire ajoute le projet à la liste des projets existants.Cliquer sur le bouton abandonner ferme l'encart et aucun projet n'est ajouté. | T1-23        | US-2       | 2                | DONE | Chaïma |
| T1-05 | Créer la barre de recherche dans le projet                   | Créer la barre de recherche dans le composant ProjectList.Cette barre de recherche doit permettre la saisie de texte. Un bouton submit doit permettre de masquer tous les projets ne correspondant pas aux termes de la       recherche. | La barre de recherche est présente dans la section projet.On peut entrer du texte dans l’input, et cliquer sur le bouton rechercher masque tous les projets ne correspondant pas aux termes de la recherche. | T1-23        | US-3       | 3                | DONE | Chaïma |
| T1-24 | Ajouter l'ajout d'une documentation sous forme de       lien et de textes dans la section Documentation | Dans le composant Documentation. Créer un menu de navigation sur la gaucheCréer un formulaire   avec pour champ:- un champ lien : une chaîne de caractères correspondant au lien à ajouter. Au sein d’une section lien, créer un bouton “ajouter un lien” associé à ce formulaire, cliquer dessus envoie le formulaire.Afficher la liste des liens dans cette section, chaque lien est cliquable. Au sein d’une section texte, afficher un éditeur de texte pour pouvoir ajouter la documentation en format Text. | Un menu de navigation est présent.On peut ajouter des liens et cliquer dessus pour les ouvrir.On peut ajouter de la documentation au format Text. | T1-03        | US-22      | 2                | TODO  |                |
| T1-28 | Ajouter l'ajout d'une documentation sous forme de posts dans la section Documentation | Dans le composant Documentation.Créer un formulaire contenant:- un champ Input : Text Area       Créer un bouton “ajouter post” lié à ce formulaire, permettant d’ajouter un post au format Markdown.Afficher la liste des posts sous forme de liens cliquables: cliquer sur lien devra ouvrir un formulaire   permettant de modifier le post.Afficher chaque post de la liste sous cette liste. | Cliquer sur le bouton ajouter post ouvre le formulaire d'ajout de post.On peut ajouter des posts sous forme de liens cliquables, et visualiser chaque posts. | T1-03        | US-22      | 2                | TODO  |                |
| T2-48 | Bouton de suppression et de modification d'un test.          | Ajouter deux boutons dans le composant TestItem, un pour la suppression, et un pour l’édition. Cliquer sur le bouton d’édition doit ouvrir une popup dans laquelle se trouve un formulaire proposant l’édition du titre ainsi que la description du test. Le bouton de suppression doit ouvrir une popup demandant confirmation pour la suppression. | Quand une édition est réalisée, la requête update est envoyée au serveur.Lors de l’appuie sur suppression, une requête delete est envoyée au serveur.Les changements côtés front doivent être réalisées automatiquement sans attendre le retour du serveur. |              | US-23      | 2                |       |                |
| T2-49 | Ajout de test                                                | Créer le bouton permettant l'ajout d'un test. Un formulaire doit s’ouvrir permettant de renseigner le nom et la description de la tâche.Le statut de la tâche après création est “not executed”. | Lors de l’ajout d’une tâche, la requête post est correctement envoyée. |              | US-23      | 2                |       |                |
| T1-25 | Création bouton d’importation.                               | Créer un bouton Importer permettant d’ouvrir l’explorateur de fichiers pour choisir un fichier récapitulatif de tests au format .json.Faire une requête PUT sur ‘/api/tests’ en spécifiant le fichier json. | On peut importer un fichier de tests par l’interface graphique ou par requêtes.L’état des tests sur le serveur est mis à jour avec les données si elles sont correctes. | T1-07, T1-10 | US-24      | 1                | TODO  |                |
| T1-10 | Spécifier le format json pour les tests                      | Dans la section “how-to”, dans la partie des tests, ajouter la partie sur le format à respecter pour ajouter automatiquement des tests. Ce format devra être : [       { name: …, description: ....,       lastExecution: …., state: …., },] | La spécification est visible dans la partie tests de la section “how-to” | T1-02        | US-24      | 1                | TODO  |                |
| T1-29 | Créer l'environnement de test pour le back.                  | Créer une base de données pour permettre la réalisation des tests. Cette base de données servira pour lancer les tests dessus. Elle comportera les mêmes tables que celles créées pour le projet afin de pouvoir tester toutes les fonctionnalités proposées.Les tests Junit doivent pouvoir se lancer. | Les tests se lancent sur la bdd de test.                     | T0-00        |            | 4                | DONE  | Robin          |
| T2-50 | Créer le model côté front pour la gestion des DOD       | Créer le fichier dod.model.ts exportant la classe Member. Cette classe doit posséder les mêmes champs que DOD.java côté back. | Le fichier est créé, la classe est instanciable avec le json reçu depuis le serveur. | T0-00       | US-17       | 1                | DONE |      Alexis          |
| T2-51 | Créer l'endpoint pour DOD       | Créer l’endpoint permettant de gérer les DOD. Les opérations GET, UPDATE, POST et DELETE doivent être disponibles. | Les routes doivent être accessibles. La bdd est bien mise à jour en fonction des routes utilisées. | T0-00       | US-17       | 1                | DONE |      Alexis + Adrien          |
| T2-52 | Créer des actions github       | Se renseigner sur les actions github et en créer afin de linter le code et tester les release automatiquement. | Les actions github doivent être exécutées après un push sur la branche main. Les Pull Request doivent être validées par les actions avant de pouvoir les merge en release. | T0-00       |        | 4                | DONE |   Adrien             |
| T2-53 | Ajouter une action pour linter automatiquement       | Se renseigner sur l'ajout d'un linter avec des actions github et rajouter un workflow sur github qui sera automatiquement executé. | L'action doit être exécutée après un push sur la branch main. Les Pull Requests doivent être validées par cette action notamment avant de pouvoir merge. | T0-00       |        | 3                | DOING |   Robin             |
